<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NgÃ¢n KhÃ¹ng By Tonkiettyphu</title>
    <style>
        /* 4. ä¸°å¯ŒèƒŒæ™¯å±‚æ¬¡ï¼šä½¿ç”¨æ·±é‚ƒçš„è“ç´«æ¸å˜èƒŒæ™¯ï¼Œå¢åŠ æ°›å›´æ„Ÿ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #1a0f2e 0%, #090514 60%, #000000 100%);
            font-family: 'Courier New', serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        /* 5. UI å­—ä½“å‡çº§ï¼šæ›´äº®ã€æ›´å¼ºçš„é‡‘è‰²å…‰æ™• */
        .header { text-align: center; color: #FFD700; text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 165, 0, 0.6); }
        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 2.5rem; }
        .status { color: rgba(255,255,255,0.8); font-size: 0.9rem; margin-top: 10px; font-weight: bold;}
        
        #cam-preview {
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px; 
            border: 2px solid rgba(255, 215, 0, 0.5); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #upload-container {
            pointer-events: auto; position: absolute; bottom: 20px; right: 20px;
            background: rgba(255,215,0,0.15); backdrop-filter: blur(10px);
            padding: 12px 24px; border: 2px solid rgba(255, 215, 0, 0.6); border-radius: 30px;
            cursor: pointer; transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        #upload-container:hover { background: rgba(255, 215, 0, 0.3); border-color: #FFD700; box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
        input[type="file"] { display: none; }
        .btn-text { color: #FFD700; font-size: 1rem; letter-spacing: 2px; font-weight: bold; text-shadow: 0 0 5px rgba(255,215,0,0.5);}

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            background: #000; display: flex; align-items: center; justify-content: center;
            color: #FFD700; transition: opacity 0.5s; font-size: 1.5rem; letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">IGNITING FESTIVE MAGIC...</div>

    <audio id="bgm" src="./music.mp3" loop hidden></audio>

    <div id="ui">
        <div class="header">
            <h1>Merry ChristmasğŸ…</h1>
            <div class="status" id="status-text">Waiting for camera...</div>
            <div class="status" style="font-size: 0.7rem; color: #aaa;">âœŠ Náº®M: CÃ¢y | ğŸ– BÃ€N TAY: Ráº£i | âœŒï¸ 2 NGÃ“N: Táº­p Trung áº¢nh</div>
        </div>
        
        <div id="cam-preview">
            <video id="webcam" autoplay playsinline></video>
        </div>

        <div id="upload-container" onclick="document.getElementById('file-input').click()">
            <span class="btn-text">Táº¢I áº¢NH LÃŠN</span>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        // --- CONFIG (è‰²å½©æ›´é¥±å’Œ) ---
        const CONF = {
            particleCount: 3500, // ç¨å¾®å¢åŠ ç²’å­æ•°é‡
            // ä½¿ç”¨æ›´é²œè‰³ã€é¥±å’Œåº¦æ›´é«˜çš„é¢œè‰²
            colors: [0x006400, 0xFFC125, 0xDC143C, 0xF0F8FF], // Deep Green, Rich Gold, Crimson Red, Alice Blue
            treeHeight: 25,
            treeRadius: 10,
            scatterRadius: 30
        };

        let scene, camera, renderer, composer, controls;
        let particlesMesh, dummy = new THREE.Object3D();
        let photos = [];
        let photoGroup = new THREE.Group();
        let gestureRecognizer;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        let lastVideoTime = -1;
        let currentGesture = "None";
        let state = "TREE";
        let targetRotationY = 0;
        
        const particlesData = [];

        async function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            // ç§»é™¤é›¾æ•ˆï¼Œè®©èƒŒæ™¯çš„æ¸å˜æ˜¾éœ²å‡ºæ¥ï¼Œå¢åŠ é€šé€æ„Ÿ
            // scene.fog = new THREE.FogExp2(0x050505, 0.02); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // ä½¿ç”¨ ACESFilmic ä½¿å¾—é«˜å…‰è¿‡æ¸¡æ›´è‡ªç„¶
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // ç¨å¾®æé«˜æ›å…‰
            container.appendChild(renderer.domElement);

            // --- 2. å¼ºåŒ–è¾‰å…‰ç‰¹æ•ˆ (Bloom) ---
            const renderScene = new RenderPass(scene, camera);
            // å‚æ•°è°ƒæ•´ï¼šå¼ºåº¦(strength)å’ŒåŠå¾„(radius)å¤§å¹…å¢åŠ 
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.8, 0.85);
            bloomPass.threshold = 0.1; // é™ä½é˜ˆå€¼ï¼Œè®©æ›´å¤šç‰©ä½“å‘å…‰
            bloomPass.strength = 2.5;  // æé«˜å¼ºåº¦ï¼Œåˆ¶é€ å¼ºçƒˆçš„å…‰æ™•
            bloomPass.radius = 0.8;    // å¢åŠå¾„ï¼Œè®©å…‰æ™•æ›´æŸ”å’Œ

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- 3. æå‡ç¯å…‰ç³»ç»Ÿ ---
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0); // ç¯å¢ƒå…‰äº®åº¦ï¼ˆç»§ç»­è°ƒä½ä¿æŠ¤ç…§ç‰‡ï¼‰
            scene.add(ambientLight);

            // ä¸»é‡‘è‰²å…‰æº
            const pointLight = new THREE.PointLight(0xFFD700, 5, 150); // æé«˜å¼ºåº¦å’ŒèŒƒå›´
            pointLight.position.set(10, 20, 20);
            scene.add(pointLight);
            
            // è¾…åŠ©æš–çº¢å…‰æºï¼Œå¢åŠ è‰²å½©å±‚æ¬¡
            const pointLight2 = new THREE.PointLight(0xFF4500, 3, 150);
            pointLight2.position.set(-15, -10, 15);
            scene.add(pointLight2);
            
            // é¡¶éƒ¨å†·å…‰ï¼Œå‹¾å‹’è½®å»“
            const topLight = new THREE.DirectionalLight(0xAABBFF, 2);
            topLight.position.set(0, 50, 0);
            scene.add(topLight);

            createParticles();
            scene.add(photoGroup);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            await setupMediaPipe();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            animate();
        }

        // --- 1. å¢å¼ºæè´¨çš„è‡ªå‘å…‰ (Emissive) ---
        function createParticles() {
            const geometry = new THREE.SphereGeometry(0.25, 12, 12); // ç¨å¾®å¢å¤§ç²’å­å¹¶å¢åŠ é¢æ•°
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3, // æ›´å…‰æ»‘
                metalness: 0.9, // æ›´å¼ºçš„é‡‘å±æ„Ÿ
                emissive: 0x333333, // åŸºç¡€è‡ªå‘å…‰
                emissiveIntensity: 0.2
            });

            particlesMesh = new THREE.InstancedMesh(geometry, material, CONF.particleCount);
            
            const color = new THREE.Color();
            const emissiveColor = new THREE.Color();

            for (let i = 0; i < CONF.particleCount; i++) {
                // ... (ä½ç½®è®¡ç®—é€»è¾‘ä¸å˜)
                const y = Math.random() * CONF.treeHeight - CONF.treeHeight / 2;
                const normY = (y + CONF.treeHeight / 2) / CONF.treeHeight;
                const r = (1 - normY) * CONF.treeRadius;
                const theta = Math.random() * Math.PI * 2 * 7; // å¢åŠ èºæ—‹åœˆæ•°
                
                const treeX = r * Math.cos(theta) + (Math.random()-0.5)*0.5; // åŠ ä¸€ç‚¹éšæœºæŠ–åŠ¨
                const treeZ = r * Math.sin(theta) + (Math.random()-0.5)*0.5;
                const treePos = new THREE.Vector3(treeX, y, treeZ);

                const phi = Math.acos(-1 + (2 * i) / CONF.particleCount);
                const sqrtPhi = Math.sqrt(CONF.particleCount * Math.PI) * phi;
                const sx = CONF.scatterRadius * Math.cos(sqrtPhi) * Math.sin(phi);
                const sy = CONF.scatterRadius * Math.sin(sqrtPhi) * Math.sin(phi);
                const sz = CONF.scatterRadius * Math.cos(phi);
                const scatterPos = new THREE.Vector3(sx, sy, sz);

                dummy.position.copy(treePos);
                // éšæœºç¼©æ”¾ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ
                const scale = Math.random() * 0.4 + 0.8;
                dummy.scale.setScalar(scale);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);

                // è®¾ç½®é¢œè‰²å’Œå¼ºå‘å…‰
                const colorHex = CONF.colors[Math.floor(Math.random() * CONF.colors.length)];
                color.setHex(colorHex);
                
                // 30% çš„ç²’å­ä½œä¸ºé«˜äº®"ç¯ç "
                if (Math.random() > 0.7) {
                    // ä½¿ç”¨é‡‘è‰²æˆ–çº¢è‰²ä½œä¸ºé«˜äº®å‘å…‰è‰²
                    const isGold = Math.random() > 0.5;
                    emissiveColor.setHex(isGold ? 0xFFD700 : 0xFF0000);
                    // æå¤§åœ°æé«˜å‘å…‰å¼ºåº¦ï¼Œé…åˆ Bloom äº§ç”Ÿè€€çœ¼æ•ˆæœ
                    particlesMesh.setColorAt(i, emissiveColor.multiplyScalar(2)); 
                } else {
                    particlesMesh.setColorAt(i, color);
                }

                particlesData.push({
                    treePos: treePos,
                    scatterPos: scatterPos,
                    currentPos: treePos.clone(),
                    velocity: new THREE.Vector3(),
                    offset: Math.random() * 100,
                    baseScale: scale // å­˜å‚¨åŸºç¡€ç¼©æ”¾å€¼
                });
            }

            particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(particlesMesh);
        }

        function createPhoto(imgUrl) {
            // ä½¿ç”¨å›è°ƒå‡½æ•°ï¼šåªæœ‰å½“å›¾ç‰‡åŠ è½½å®Œæ¯•å(texture)ï¼Œæ‰ä¼šæ‰§è¡ŒèŠ±æ‹¬å·é‡Œçš„ä»£ç 
            new THREE.TextureLoader().load(imgUrl, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                
                // 1. è·å–å›¾ç‰‡å®é™…é•¿å®½æ¯”
                const img = texture.image;
                let aspectRatio = 1;
                if (img.width && img.height) {
                    aspectRatio = img.width / img.height;
                }

                // 2. è®¾å®šæœ€å¤§å°ºå¯¸é™åˆ¶ (ç±»ä¼¼ CSS çš„ max-width/max-height)
                const MAX_SIZE = 4; // è®¾å®šä¸€ä¸ªåŸºå‡†å°ºå¯¸
                
                let width, height;

                // ç®€å•çš„è‡ªé€‚åº”ç®—æ³•ï¼š
                // å¦‚æœæ˜¯å®½å›¾ (Landscape)
                if (aspectRatio >= 1) {
                    width = MAX_SIZE;
                    height = MAX_SIZE / aspectRatio;
                } 
                // å¦‚æœæ˜¯é•¿å›¾ (Portrait)
                else {
                    height = MAX_SIZE;
                    width = MAX_SIZE * aspectRatio;
                }
                
                const geometry = new THREE.PlaneGeometry(width, height);
                
                // --- æè´¨è®¾ç½® (ä¿æŒä¹‹å‰çš„æš—ç°è‰²é˜²è¿‡æ›) ---
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.FrontSide, 
                    transparent: true,
                    opacity: 1.0,
                    color: 0x777777 // æš—ç°è‰²
                });

                // --- èƒŒé¢é‡‘æ¿ (éœ€è¦è·Ÿç€æ”¹å˜å°ºå¯¸) ---
                const glowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,      // äº®é‡‘è‰²
                    side: THREE.BackSide, 
                    metalness: 1.0,       
                    roughness: 0.2,       // æ›´å…‰æ»‘ï¼Œäº§ç”Ÿé«˜å…‰
                    emissive: 0xCC8800,   // æš—é‡‘è‰²è‡ªå‘å…‰
                    emissiveIntensity: 0.3 // é™ä½è‡ªå‘å…‰å¼ºåº¦
                });

                const glowMesh = new THREE.Mesh(geometry, glowMaterial);
                glowMesh.position.z = -0.01; 
                
                const mesh = new THREE.Group();
                mesh.add(new THREE.Mesh(geometry, material));
                mesh.add(glowMesh);
                
                // --- è®¾ç½®éšæœºä½ç½® ---
                mesh.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                
                mesh.userData = {
                    treePos: new THREE.Vector3(
                        (Math.random() - 0.5) * CONF.treeRadius * 1.2, 
                        (Math.random() - 0.5) * CONF.treeHeight * 0.8, 
                        CONF.treeRadius + 3
                    ),
                    scatterPos: mesh.position.clone(),
                    // è®°å½•åŸå§‹æ¯”ä¾‹ï¼Œé˜²æ­¢åŠ¨ç”»ç¼©æ”¾æ—¶å˜å½¢
                    originalScale: new THREE.Vector3(1, 1, 1), 
                    isFocused: false
                };

                photos.push(mesh);
                photoGroup.add(mesh);
            });
        }

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: runningMode
            });

            const video = document.getElementById("webcam");
            const constraints = { video: true };
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                webcamRunning = true;
            });
        }

        async function predictWebcam() {
            const video = document.getElementById("webcam");
            if (!gestureRecognizer || !webcamRunning || video.videoWidth === 0) return;

            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                const statusText = document.getElementById('status-text');
                
                if (results.gestures.length > 0) {
                    const category = results.gestures[0][0].categoryName;
                    const hand = results.landmarks[0];
                    currentGesture = category;

                    if (category === "Closed_Fist") {
                        state = "TREE";
                        statusText.innerText = "State: TREE (Coalescing)";
                        statusText.style.color = "#00FF7F"; // Spring Green
                        controls.autoRotate = true;
                    } else if (category === "Open_Palm") {
                        state = "SCATTER";
                        statusText.innerText = "State: SCATTER (Exploding)";
                        statusText.style.color = "#FFD700"; // Gold
                        controls.autoRotate = false;
                        
                        if(hand) {
                            const wrist = hand[0];
                            targetRotationY = (wrist.x - 0.5) * 8; // å¢åŠ æ—‹è½¬çµæ•åº¦
                        }

                    } else if (category === "Victory" || category === "Thumb_Up") {
                        state = "FOCUS";
                        statusText.innerText = "State: MEMORY (Focusing)";
                        statusText.style.color = "#FF4500"; // Orange Red
                        controls.autoRotate = false;
                    }
                } else {
                    currentGesture = "None";
                    targetRotationY = 0;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            predictWebcam();
            
            const time = performance.now() * 0.001;

            updateParticles(time);
            updatePhotos(time);

            if (state === "SCATTER") {
                scene.rotation.y += (targetRotationY - scene.rotation.y) * 0.08;
            } else if (state === "TREE" && controls.autoRotate) {
                // OrbitControls handles auto-rotation
            }

            controls.update();
            // ä½¿ç”¨ composer æ¸²æŸ“ä»¥åº”ç”¨è¾‰å…‰æ•ˆæœ
            composer.render();
        }

        function updateParticles(time) {
            for (let i = 0; i < CONF.particleCount; i++) {
                const data = particlesData[i];
                let target;

                if (state === "TREE" || state === "FOCUS") {
                    target = data.treePos;
                } else {
                    target = data.scatterPos;
                }

                data.currentPos.lerp(target, 0.04); // ç¨å¾®åŠ å¿«èšåˆé€Ÿåº¦

                if (state === "SCATTER") {
                    data.currentPos.y += Math.sin(time + data.offset) * 0.03;
                    data.currentPos.x += Math.cos(time + data.offset * 0.5) * 0.02;
                }

                dummy.position.copy(data.currentPos);
                
                // åŠ¨æ€ç¼©æ”¾ï¼šåœ¨æ ‘å½¢æ€ä¸‹æœ‰è½»å¾®å‘¼å¸æ„Ÿï¼Œåœ¨æ•£å¼€å½¢æ€ä¸‹éšæœºé—ªçƒ
                let scaleVariation = Math.sin(time * 2 + data.offset) * 0.1;
                if (state === "SCATTER") scaleVariation = Math.sin(time * 5 + i) * 0.3;
                
                dummy.scale.setScalar(data.baseScale + scaleVariation);
                
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;
        }

        function updatePhotos(time) {
            if (photos.length === 0) return;

            photos.forEach((photoGroup, index) => {
                let targetPos, targetScale, targetRot;
                const photo = photoGroup.children[0]; // Access the photo mesh inside the group

                if (state === "FOCUS") {
                    const focusIndex = Math.floor(time * 0.4) % photos.length; 
                    
                    if (index === focusIndex) {
                        const camDir = new THREE.Vector3();
                        camera.getWorldDirection(camDir);
                        targetPos = camera.position.clone().add(camDir.multiplyScalar(12));
                        targetScale = new THREE.Vector3(2.5, 2.5, 2.5);
                        photoGroup.lookAt(camera.position);
                    } else {
                        targetPos = photoGroup.userData.scatterPos.clone().multiplyScalar(1.5); // Push further back
                        targetScale = new THREE.Vector3(0.3, 0.3, 0.3);
                    }
                } else if (state === "TREE") {
                    const theta = time * 0.15 + (index / photos.length) * Math.PI * 4;
                    const r = CONF.treeRadius + 3 + Math.sin(time + index)*0.5;
                    const h = (index / photos.length - 0.5) * CONF.treeHeight * 0.8;
                    targetPos = new THREE.Vector3(Math.cos(theta) * r, h, Math.sin(theta) * r);
                    targetScale = new THREE.Vector3(0.8, 0.8, 0.8);
                    photoGroup.lookAt(new THREE.Vector3(0, targetPos.y, 0));
                    photoGroup.rotateY(Math.PI); // Flip to face outwards
                } else {
                    targetPos = photoGroup.userData.scatterPos;
                    targetPos.y += Math.sin(time + index) * 0.08;
                    targetPos.x += Math.cos(time + index * 0.5) * 0.05;
                    targetScale = new THREE.Vector3(1.2, 1.2, 1.2);
                    photoGroup.lookAt(camera.position);
                }

                photoGroup.position.lerp(targetPos, 0.04);
                photoGroup.scale.lerp(targetScale, 0.04);
            });
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length > 0) {
                // 1. å¤„ç†å›¾ç‰‡é€»è¾‘ (ä¿æŒä¸å˜)
                for (let file of files) {
                    const url = URL.createObjectURL(file);
                    createPhoto(url);
                }
                state = "TREE";
                controls.autoRotate = true;

                // --- æ ¸å¿ƒæ–°å¢ï¼šå¼€å§‹æ’­æ”¾éŸ³ä¹ ---
                const audio = document.getElementById('bgm');
                // è®¾ç½®éŸ³é‡ (0.0 åˆ° 1.0)ï¼Œå»ºè®® 0.5 æ¯”è¾ƒæŸ”å’Œ
                audio.volume = 0.5; 
                
                // å°è¯•æ’­æ”¾
                audio.play().then(() => {
                    console.log("Music started!");
                    // å¯é€‰ï¼šè®©éŸ³ä¹æ·¡å…¥ (Fade In)
                    gsap.fromTo(audio, {volume: 0}, {volume: 0.5, duration: 3});
                }).catch(error => {
                    console.error("éŸ³ä¹æ’­æ”¾å¤±è´¥:", error);
                    // å¦‚æœå› ä¸ºæµè§ˆå™¨ç­–ç•¥å¤±è´¥ï¼Œå¯ä»¥åœ¨è¿™é‡Œæç¤ºç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
